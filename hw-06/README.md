## Домашнее задание к занятию № 6 — «Bash, awk, sed, grep и другие»    <!-- omit in toc -->

### Оглавление  <!-- omit in toc -->

- [Содержимое каталога](#Содержимое-каталога)
- [Описание работы скрипта](#Описание-работы-скрипта)
- [Запуск скрипта по расписанию](#Запуск-скрипта-по-расписанию)
- [Проверка защиты от мультизапуска](#Проверка-защиты-от-мультизапуска)
- [Что можно улучшить](#Что-можно-улучшить)

### Содержимое каталога

[access-4560-644067.log](access-4560-644067.log) — входной файл для анализа (представляет собой лог-файл Nginx).

[monitor.sh](monitor.sh) — bash-скрипт, который обрабатывает входной файл.

[README.md](README.md) — это описание.

Также в процессе выполнения скрипта в рабочем каталоге создаются два дополнительных файла, которые добавлены в [.gitignore](.gitignore):

**lastrun.log** — файл, в который записывается время последнего выполнения скрипта;

**result.log** — результирующий файл, куда записывается результат работы скрипта и содержимое которого отправляется по электронной почте. Используется именно файл, а не переменная, по двум причинам:
1. Для удобства отладки.
2. Для проверки работы скрипта в случае сбоя почтовой рассылки.

### Описание работы скрипта

1. Проверка блокирующего файла для защиты от мультизапуска: если файла нет, то он создаётся и выполняется основная логика скрипта, а если файл уже есть — выводится сообщение о блокировке:

    ```bash
    lockfile=/tmp/monitor
    if ( set -o noclobber; echo "$$" > "$lockfile") 2> /dev/null;
    then
        trap 'rm -f "$lockfile"; exit $?' INT TERM EXIT
        ### Основное тело скрипта
        ...
    else
        echo "Failed to acquire lockfile: $lockfile"
        echo "Held by $(cat $lockfile)"
    fi
    ```

2. Задаются переменные: время запуска скрипта, входной и выходной файлы, лог-файл с временем последнего выполнения, адрес электронной почты, количество IP-адресов и запрашиваемых адресов (задаются как входные параметры), количество IP-адресов и запрашиваемых адресов по умолчанию (используются, если скрипт запущен без параметров).
3. Если переменные с количеством адресов не заполнены (скрипт запущен без параметров), им задаётся стандартное значение:

    ```bash
    if [[ -z $countFrom ]]
    then
        countFrom=$defaultCountFrom
    fi
    if [[ -z $countTo ]]
    then
        countTo=$defaultCountTo
    fi
    ```
    
4. Задаётся функция **topList** — вывод отсортированного количества строк с их количеством с использованием программы awk, обрабатывающей первый столбец. При помощи регулярных выражений в функции описан выбор формы слова «раз» в зависимости от числа:

    ```bash
    topList() {
        echo "$1" | awk '{ ipcount[$1]++ } END { for (i in ipcount) \
                         { if (ipcount[i] ~ /^[2-4]$|[^1][2-4]$/) case="раза"; else case="раз"; \
                         printf "%s - %d %s\n", i, ipcount[i],case } }' | sort -rnk3 -k1 | head -$2
    }
    ```
5. Из лог-файла считывается время последнего запуска. Если лог-файла нет или он пустой, то этим временем считается время, указанное в первой строке входного файла:
    
    ```bash
    if [[ -s $logFile ]]
    then
        lastTime=$(tail -1 $logFile)
    else
        lastTime=$(head -1 $inputFile | cut -d" " -f4 | cut -c2-)
    fi
    ```

6. В новую переменную записываются данные из входного файла в промежутке от времени последнего запуска до времени запуска скрипта. Все дальшейшие действия в скрипте проводятся именно над этими данными:

    ```bash
    logInterval=$(cat "$inputFile" | awk -v lastTime=$lastTime -v timeNow=$timeNow \
                                     '{sub(/\[/,"",$4); if ($4 >= lastTime && $4 < timeNow) print $0}')
    ```

7. В выходной файл записывается обрабатываемый диапазон времени:

    ```bash
    echo "Данные за промежуток между $lastTime и $timeNow" > $outputFile
    echo '' >> $outputFile
    ```

8. В выходной файл записывается результат работы функции **topList** над исходными данными — отсортированный список заданного числа IP-адресов с их количеством:

    ```bash
    echo "Топ $countFrom IP-адресов:" >> $outputFile
    topList "$logInterval" $countFrom >> $outputFile
    echo '' >> $outputFile
    ```

9.  Создаётся новая переменная, в которую при помощи программы awk запоминаются запрашиваемые адреса. Если в запросе не указан метод (GET, POST и т. д.), вместо адреса указывается прочерк:

    ```bash
    addrList=$(echo "$logInterval" | awk '{ if ($6 ~ /^"[A-Z]+$/) print $7; else print "-" }')
    ```

10. В выходной файл записывается результат работы функции **topList** над этой переменной — отсортированный список заданного числа запрашиваемых адресов с их количеством:

    ```bash
    topList "$addrList" $countTo >> $outputFile
    echo '' >> $outputFile
    ```

11. Создаётся новая переменная, в которую при помощи программы awk запоминаются коды возврата. Если в подстроке запроса не три поля, а одно, то код возврата содержится не в девятом поле всей строки файла, а в седьмом. Такие случаи также обрабатываются awk:

    ```bash
    codeList=$(echo "$logInterval" | awk '{ if ($9 ~ /^[0-9]+$/) print $9; else print $7 }')
    ```

12. Удаляются все дубликаты из списка кодов возврата, после чего при помощи программы sed оставляются только коды ошибок (всё, что не начинается на 2 и 3). Результат записывается в выходной файл:

    ```bash
    echo 'Присутствующие ошибки:' >> $outputFile
    echo "$codeList" | sort -u | sed '/^[23]/d' >> $outputFile
    echo '' >> $outputFile
    ```

13. В выходной файл записывается результат работы функции **topList** над списком кодов возврата — отсортированный список кодов с их количеством. Так как в теле **topList** используется команда `head`, то в качестве второго параметра передаётся количество уникальных кодов, чтобы не усложнять функцию дополнительными условиями:

    ```bash
    echo 'Коды возврата:' >> $outputFile
    codeCount=$(echo "$codeList" | sort -u | wc -l)
    topList "$codeList" $codeCount >> $outputFile
    ```

14. Время выполнения скрипта записывается в лог-файл:

    ```bash
    if [[ -e $logFile ]]
    then
        echo $timeNow >> $logFile
    else
        echo $timeNow > $logFile
    fi
    ```

15. Содержимое выходного файла отправляется по электронной почте на заданный адрес:

    ```bash
    cat $outputFile | mail -s "Result of monitoring at $timeNow" $emailAddress
    ```

16. Удаляется блокирующий файл, возвращается стандартный обработчик сигнала:

    ```bash
    rm -f "$lockfile"
    trap - INT TERM EXIT
    ```

### Запуск скрипта по расписанию

1. При помощи команды sed проставить в файле [access-4560-644067.log](access-4560-644067.log) дату, когда запускается скрипт, например:
    
    ```console
    $ sed -i 's|14/Aug/2019|26/Jan/2020|' ./access-4560-644067.log
    ```
    Необходимо учитывать, что в конце файла содержатся данные за следующий день, и обрабатывать их тоже, иначе они исказят выборку:

    ```console
    $ sed -i 's|15/Aug/2019|27/Jan/2020|' ./access-4560-644067.log
    ```

2. Убедиться, что на машине установлен пакет mailx.

    Для CentOS:

    ```console
    $ sudo yum install -y mailx
    ```
    
    Для Ubuntu:
    
    ```console
    $ sudo apt install -y mailutils
    ```

3. Сделать скрипт выполняемым:
    
    ```console
    $ chmod +x ./monitor.sh
    ```

4. При помощи команды `crontab -e` открыть файл конфигурации cron в редакторе и добавить задание на выполнение скрипта каждый час. Так как в скрипте прописаны относительные пути, также следует предусмотреть переход в каталог, содержащий скрипт, например:
    
    ```
    @hourly cd ~/repos/linux-hw/hw-06 && ./monitor.sh 8 7
    ```

    Вместо указанных чисел в параметрах можно выбрать другие (или не указывать их вообще).

    Чтобы убедиться, что рассылка по расписанию работает, можно выставить меньший промежуток, например, 10 минут:

    ```
    0/10 * * * * cd ~/repos/linux-hw/hw-06 && ./monitor.sh 8 7
    ```

5. Спустя какое-то время (достаточное для нескольких запусков по расписанию) проверить входящую почту при помощи команды `sudo mail` (если получателем был выбран текущий пользователь, отличный от root, то команда `sudo` не нужна):
    
    ```console
    $ sudo mail
    "/var/mail/root": 4 messages 3 new 1 unread
     U   1 rustsh             Sun Jan 26 15:00  51/1290  Result of monitoring at 26/Jan/2020:15:00:01
    >N   2 rustsh             Sun Jan 26 16:00  42/1287  Result of monitoring at 26/Jan/2020:16:00:01
     N   3 rustsh             Sun Jan 26 17:00  41/1116  Result of monitoring at 26/Jan/2020:17:00:01
     N   4 rustsh             Sun Jan 26 18:00  42/1355  Result of monitoring at 26/Jan/2020:18:00:01
    ? 
    ```
    
    <details>
    <summary>Посмотреть содержимое письма (раскрывается при нажатии)</summary>

    ```console
    ? 4
    Return-Path: <rustsh@lenovo>
    X-Original-To: root@localhost
    Delivered-To: root@localhost
    Received: by lenovo (Postfix, from userid 1000)
            id 8E8094C0A34; Sun, 26 Jan 2020 18:00:01 +0500 (+05)
    Subject: Result of monitoring at 26/Jan/2020:18:00:01
    To: <root@localhost>
    X-Mailer: mail (GNU Mailutils 3.4)
    Message-Id: <20200126130001.8E8094C0A34@lenovo>
    Date: Sun, 26 Jan 2020 18:00:01 +0500 (+05)
    From: rustsh <rustsh@lenovo>
    Status: O
    X-UID: 4

    Данные за промежуток между 26/Jan/2020:17:00:01 и 26/Jan/2020:18:00:01

    Топ 8 IP-адресов:
    148.251.223.21 - 22 раза
    213.202.100.91 - 3 раза
    167.99.14.153 - 3 раза
    185.12.124.78 - 2 раза
    66.249.64.204 - 2 раза
    209.17.96.226 - 1 раз
    141.8.189.176 - 1 раз
    93.158.167.130 - 1 раз

    Топ 7 запрашиваемых адресов:
    / - 7 раз
    /wp-login.php - 4 раза
    /robots.txt - 3 раза
    /xmlrpc.php - 2 раза
    /tag/dublicate/ - 2 раза
    /%D0%A3%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5-%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%A1%D0%A3%D0%91%D0%94-oracle/ - 2 раза
    /wp-cron.php?doing_wp_cron=1565792067.0530738830566406250000 - 1 раз

    Присутствующие ошибки:
    400
    404

    Коды возврата:
    200 - 32 раза
    301 - 6 раз
    404 - 3 раза
    400 - 1 раз
    ? 
    ```
    </details>

6. Также можно проверить содержимое файлов **lastrun.log** и **result.log**:
    
    ```console
    $ cat lastrun.log 
    26/Jan/2020:15:00:01
    26/Jan/2020:16:00:01
    26/Jan/2020:17:00:01
    26/Jan/2020:18:00:01
    ```
    
    <details>
    <summary>Посмотреть результат выполнения команды <code>cat result.log</code> (раскрывается при нажатии)</summary>
    
    ```console
    $ cat result.log 
    Данные за промежуток между 26/Jan/2020:17:00:01 и 26/Jan/2020:18:00:01

    Топ 8 IP-адресов:
    148.251.223.21 - 22 раза
    213.202.100.91 - 3 раза
    167.99.14.153 - 3 раза
    185.12.124.78 - 2 раза
    66.249.64.204 - 2 раза
    209.17.96.226 - 1 раз
    141.8.189.176 - 1 раз
    93.158.167.130 - 1 раз

    Топ 7 запрашиваемых адресов:
    / - 7 раз
    /wp-login.php - 4 раза
    /robots.txt - 3 раза
    /xmlrpc.php - 2 раза
    /tag/dublicate/ - 2 раза
    /%D0%A3%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5-%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%A1%D0%A3%D0%91%D0%94-oracle/ - 2 раза
    /wp-cron.php?doing_wp_cron=1565792067.0530738830566406250000 - 1 раз

    Присутствующие ошибки:
    400
    404

    Коды возврата:
    200 - 32 раза
    301 - 6 раз
    404 - 3 раза
    400 - 1 раз
    ```
    </details>

7. Чтобы отключить выполнение по расписанию, нужно открыть файл конфигурации командой `crontab -e` и удалить соответствующую строку. Если других заданий нет, то вместо этого достаточно выполнить команду `crontab -r`.

### Проверка защиты от мультизапуска

1. В теле скрипта (после команды `trap`) добавить строку с командой задержки и сохранить файл:

    ```bash
    sleep 1h
    ```

2. Запустить скрипт:

    ```console
    $ ./monitor.sh
    ```

3. Открыть другое окно с терминалом (или поставить процесс на паузу с переводом в фоновый режим, нажав комбинацию **CTRL + Z**).
4. Запустить скрипт ещё раз и убедиться, что защита работает:
    
    ```console
    $ ./monitor.sh 
    Failed to acquire lockfile: /tmp/monitor
    Held by 11191
    ```

    Проверить наличие блокирующего файла:
    
    ```console
    $ cat /tmp/monitor 
    11191
    ```

5. Вернуться в первое окно с терминалом (или, если была нажата комбинация **CTRL + Z**, запустить остановленный процесс командой `fg`) и прервать выполнение скрипта комбинацией **CTRL + C**.
6. Убедиться, что блокирующий файл удалён:

    ```console
    $ cat /tmp/monitor 
    cat: /tmp/monitor: No such file or directory
    ```

### Что можно улучшить

1. В скрипте отсутствует обработка часовых поясов.
2. Для того, чтобы отправлять письма на настоящую электронную почту, нужно настроить SMTP-сервер.
3. Вывести все начальные переменные (названия файлов, e-mail и т. д.) в отдельный конфигурационный файл.
4. Вместо cron использовать systemd для более гибкой настройки.

<br/>

[Вернуться к списку всех ДЗ](../README.md)